/*
*/

require Math;
require Characters;
require FABRIK;


object ParticleState {
    Vec3 position;
    Vec3 velocity;
    Vec3 lastPos;
};

object SimSpringStrand: IFABRIKSolver {
    String        name;
    Boolean       ready;
    Skeleton      skeleton;        // sleketon
    DrawingHandle handle;
    Index         subBaseIndex;    // the index sub-base bone on skeleton
    Index         subBaseIndexInternal;  // internally use

    Index         numberOfStrands;
    Index         numberOfVertices;
    Index         rootNodeIndices[];
    Index         innerIndices[][];

    Bone          bones[][];         // the bones
    Xfo           xfos[][];          // the xfo of bone
    Index         nodeIndices[][];   // the bone index on the skeleton
    Scalar        chainLengths[];
    Integer       max_iteration;   // max iteration

    Mat44         rootControllers[];

    //////////////////////////////////////
    Vec3          positionPrev[][];

    Scalar        frameCount;
    Scalar        framePrev;
    Scalar        deltaTime;

    Index         effectorIndex;
    Index         effectorCount;

    ////////////////////////////////////////
    Index         integrationMethod;

    ParticleState    ps[];
    Scalar        masses[];

    ////////////////////////////////////////
    // simulation params
    Vec3          gravity;
    Scalar        friction;
    //Scalar        kineticFriction;
    //Scalar        staticFriction;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
/// 

function ParticleState( Vec3 pos, Vec3 vel ){
    this.position = pos;
    this.velocity = vel;
    this.lastPos  = pos;
}

function ParticleState +( ParticleState lhs, ParticleState rhs ){
    return ParticleState( lhs.position + rhs.position, lhs.velocity + rhs.velocity );
}

function ParticleState -( ParticleState lhs, ParticleState rhs ){
    return ParticleState( lhs.position - rhs.position, lhs.velocity - rhs.velocity );
}

function ParticleState *( Scalar lhs, ParticleState rhs ){
    return ParticleState( lhs * rhs.position, lhs * rhs.velocity );
}

function ParticleState.velocityVerlet( Scalar dt ){


}

///////////////////////////////////////////////////////////////////////////////////////////////////
function SimSpringStrand( Ref<Skeleton> skeleton, io DrawingHandle handle, in String boneNames[][] ){

    this.ready = false;
    this.skeleton = skeleton;
    this.handle = handle;
    //this.precision = 0.005f;
    this.max_iteration = 150;

    //this.num_bones = boneNames.size();
    this.numberOfStrands = boneNames.size;
    this.bones.resize( boneNames.size );
    this.xfos.resize( boneNames.size );
    this.chainLengths.resize( boneNames.size );
    this.nodeIndices.resize( boneNames.size );
    this.rootNodeIndices.resize( boneNames.size );
    this.positionPrev.resize( boneNames.size );
    this.effectorIndex = 0;
    this.name = this.type() +":" + this.skeleton.name +":" + boneNames[boneNames.size-1];
    this.numberOfVertices = 0;
    this.innerIndices.resize( boneNames.size );

    // velocity verlet
    //this.masses.resize( this.numberOfVertices );
    //this.ps.resize( this.numberOfVertices );

    // basic verlet
    for (Index j=0; j < boneNames.size; j++ ){
        this.rootNodeIndices[j] = skeleton.findBone( boneNames[j][0] );

        for ( Index i=0; i < boneNames[j].size; i++) {
            this.innerIndices[j].resize( boneNames[j].size );
            this.innerIndices[j][i] = this.numberOfVertices;
            this.numberOfVertices++;
            Index boneindex = skeleton.findBone( boneNames[j][i] );
            this.nodeIndices[ j ].push( boneindex );
            Bone bone = skeleton.getBone( boneindex );
            this.xfos[j].push( bone.referencePose );
            bone.length = 0.0f;  // must culculate later
            bone.name = "FABRIKSolver:bones-" + skeleton.getBone( boneindex ).name;
            //report( "add bone["+j+"]["+i+"]: " + bone.name + "   " + bone.length );
            this.positionPrev[j].push( bone.referencePose.tr );
            if ( i != 0 ){
                bone.parentIndex = this.nodeIndices[j][ i-1 ];
            } else {
                bone.parentIndex = 0;
            }

            this.bones[j].push( bone );

            this.masses.push( 1 - i*0.05 );
            this.ps.push( ParticleState(bone.referencePose.tr, Vec3()) );
        }
    }

    for (Index j=0; j < boneNames.size; j++ ){
        // calculate bone length and total chain length
        this.chainLengths[j] = 0.0f;
        for (Index i=0; i < this.bones[j].size - 1; i++) {

            Xfo tmp_parent = this.bones[j][i].referencePose;

            Scalar length = abs( ( this.xfos[j][i+1].tr - this.xfos[j][i].tr).length() );
            if ( isZero( length )) {
                setError( "zero length bone found" );
            }

            //report( "bone length ["+i+"]: " + length);
            this.bones[j][i].length = length;
            this.chainLengths[j] += length;
        }
    }


}

////////////////////////////////////////////////////////////////////////////////////////
/// implement interface ISimSpringStrand
function SimSpringStrand.Solve!( io IPose pose, in Mat44 rootControllers[] ){

    this.solveVelocityVerlet( this.deltaTime );
    //this.solveBasicVerlet( this.deltaTime );

    /*
    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        pose.setBoneXfo( this.rootNodeIndices[ i ], Xfo( rootControllers[i] ));
    }

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        this.solveEachStrand( pose, rootControllers[i].translation(), i );
    } 
    // */

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        for ( Index j=1; j < this.positionPrev[i].size; j++){
            pose.setBoneXfo( this.nodeIndices[i][j], this.xfos[i][j] );
        }
    }
    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        pose.setBoneXfo( this.rootNodeIndices[ i ], Xfo( rootControllers[i] ));
    }
}

function SimSpringStrand.Solve!( io IPose pose, in Vec3 effectorPosition ){

}


function SimSpringStrand.solveVelocityVerlet!( Scalar dt ){

    ParticleState k1[] = this.calcAccel( this.ps );
    ParticleState p2[] = this.ps.clone();
    for( Index i=0; i < this.ps.size; i++ ){
        p2[i].position.x += dt*this.ps[i].velocity.x + dt*dt/2.0*k1[i].velocity.x;
        p2[i].position.y += dt*this.ps[i].velocity.y + dt*dt/2.0*k1[i].velocity.y;
        p2[i].position.z += dt*this.ps[i].velocity.z + dt*dt/2.0*k1[i].velocity.z;
    }

    ParticleState k2[] = this.calcAccel( p2 );
    for( Index i=0; i < this.ps.size; i++ ){
        p2[i].velocity.x += dt / 2.0 * (k2[i].velocity.x + k1[i].velocity.x);
        p2[i].velocity.y += dt / 2.0 * (k2[i].velocity.y + k1[i].velocity.y);
        p2[i].velocity.z += dt / 2.0 * (k2[i].velocity.z + k1[i].velocity.z);
    }

    this.ps = p2;

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        for ( Index j=1; j < this.positionPrev[i].size; j++){
            this.xfos[i][j] = Xfo( this.ps[ this.innerIndices[i][j] ].position );
        }
    }
}


function SimSpringStrand.solveBasicVerlet!( Scalar dt ){

    Vec3 calcPoint[];
    Vec3 tempPoint[];

    ParticleState k1[] = this.calcAccel( this.ps );
    for( Index i=0; i < this.ps.size; i++ ){
        tempPoint.push( this.ps[i].position );
        calcPoint.push( this.ps[i].position );
        calcPoint[i] -= this.ps[i].lastPos;
        calcPoint[i] += k1[i].velocity;

        this.ps[i].position += calcPoint[i];
        this.ps[i].lastPos   = tempPoint[i];
    }

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        for ( Index j=1; j < this.positionPrev[i].size; j++){
            this.xfos[i][j] = Xfo( this.ps[ this.innerIndices[i][j] ].position );
        }
    }
}



function ParticleState[] SimSpringStrand.calcAccel( in ParticleState ps[] ){
    ParticleState res[] = this.calcForce( ps );
    for (Index i=0; i < this.ps.size; i++ ){
        res[i].position.x = this.ps[i].velocity.x;
        res[i].position.y = this.ps[i].velocity.y;
        res[i].position.z = this.ps[i].velocity.z;

        res[i].velocity.x /= this.masses[i];
        res[i].velocity.y /= this.masses[i];
        res[i].velocity.z /= this.masses[i];
    }

    return res;
}


function ParticleState[] SimSpringStrand.calcForce( in ParticleState ps[] ){
    ParticleState res[];
    //res.resize( this.numberOfVertices );
    res.resize( ps.size );

    for (Index i=0; i < ps.size; i++ ){
        res[i] = ParticleState(Vec3( 0, -9.8, 0 ), Vec3( 0, -9.8, 0 ));
    }

    return res;
}

function SimSpringStrand.solveEachStrand!( io IPose pose, in Vec3 effector_position, in Index index ){
    //VerletStrandBinding verletStrand = verletStrands[index];
    //report( "<-----------------" );
    for (Index j = 0; j < this.nodeIndices[ index ].size; j++) {
        this.solveEachEadge( pose, effector_position, this.bones[index], index, j);
    }
    //report( "----------------->" );
}

function SimSpringStrand.UpdateFrame!( in Scalar fc ){
    this.framePrev  = this.frameCount;
    this.frameCount = fc;
    this.deltaTime  = (this.frameCount - this.framePrev) / 30.0;
    //this.deltaTime  = 1/30;
}

/// for shortcut
inline function Xfo getReferenceLocalPose( io Skeleton skeleton, Index index ){
    return skeleton.getReferenceLocalPose( index );
}


function SimSpringStrand.SetEffectorIndex!( io Index id ){
    this.effectorIndex = id;
}

function Index SimSpringStrand.GetEffectorCount(){
    return this.effectorCount;
}

////////////////////////////////////////////////////////////////////////////////////////
///
///
///
function SimSpringStrand.solveEachEadge!(
                                            io IPose pose,
                                            in Vec3 effector_position,
                                            io Bone bones[],
                                            in Index strandIndex,
                                            in Index _nodeIndex
                                        ){

    //report( "----------:  " + strandIndex + "  : " + _nodeIndex );
    ////////////////////////////////////////////////////////////////////////////////////
    Vec3 gravity = Vec3( 0.0, -9.8, 0.0 );
    Scalar dampening = 0.005;
    Scalar springStrengths = 1.0 / (1+_nodeIndex);

    ////////////////////////////////////////////////////////////////////////////////////
    Index nodeIndex = this.nodeIndices[ strandIndex ][ _nodeIndex ];
    Bone  thisBone  = this.bones[ strandIndex ][ _nodeIndex ];
    Xfo xfoCurr = this.xfos[ strandIndex ][ _nodeIndex ];

    ////////////////////////////////////////////////////////////////////////////////////
    Xfo parentAttachedXfo = pose.getBoneXfo( this.skeleton.getBone( nodeIndex ).parentIndex );
    Xfo parentSimulatedXfo = parentAttachedXfo;
    Xfo attachedXfo = parentAttachedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );
    parentAttachedXfo = attachedXfo;



    Xfo testXfo = parentSimulatedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );
    Vec3 attachedTr = testXfo.tr + testXfo.ori.rotateVector( Vec3( thisBone.length, 0.0, 0.0) );

    Scalar mass = 1.0;
    Vec3 force = gravity;
    Vec3 trCurr = xfoCurr.tr ;//+ xfoCurr.ori.rotateVector( Vec3( thisBone.length, 0.0, 0.0) );
    Vec3 temp = trCurr;
    //this.positionPrev[ strandIndex ][ _nodeIndex ] = this.positionPrev[ strandIndex ][ _nodeIndex ].linearInterpolate(trCurr, dampening);
    this.positionPrev[ strandIndex ][ _nodeIndex ] = this.xfos[ strandIndex ][ _nodeIndex ].tr.linearInterpolate( trCurr, dampening );

    force += ((attachedTr - trCurr) * springStrengths);

    trCurr = verletIntegration(
                trCurr,
                this.positionPrev[ strandIndex ][ _nodeIndex ],
                force,
                mass,
                this.deltaTime
            );

    // Now apply the inter-link constraints that keep the chain together
    Vec3 prevAnchor, nextAnchor;
    if( _nodeIndex==0 ){
        prevAnchor = attachedXfo.tr;
    }
    else{
        prevAnchor = this.positionPrev[strandIndex][_nodeIndex-1];
    }
    Vec3 prevVec = (prevAnchor - trCurr);
    Scalar prevVecLength = prevVec.length();
    Scalar boneLength = thisBone.length;
    trCurr += (prevVec * ((prevVecLength - boneLength)/prevVecLength)) * 0.5;

    // is not end node
    if( _nodeIndex < this.nodeIndices[ strandIndex ].size-1 ){

        nextAnchor = this.positionPrev[ strandIndex ][ _nodeIndex+1];
        Vec3 nextVec = (nextAnchor - trCurr);
        Scalar nextVecLength = nextVec.length();
        Scalar nextBoneLength = this.bones[ strandIndex ][ _nodeIndex+1 ].length;
        trCurr += ( nextVec * ((nextVecLength - nextBoneLength) / nextVecLength) ) * 0.5;
    }

    Vec3 simulatedTr = attachedTr.linearInterpolate(trCurr, 1.0);
    Xfo simulatedXfo = parentSimulatedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );

    //Quat boneOffsetRotation;
    //boneOffsetRotation.setFrom2Vectors(simulatedXfo.ori.getXaxis(), (simulatedTr - simulatedXfo.tr).unit());
    //simulatedXfo.ori = boneOffsetRotation * simulatedXfo.ori;

    this.xfos[ strandIndex ][ _nodeIndex ] = simulatedXfo;

    parentSimulatedXfo = simulatedXfo;
    //this.positionPrev[ strandIndex ][ _nodeIndex ] = temp;
}

inline function SimulateStrand( in Vec3 pos, in Vec3 prev ){


}

inline function Vec3 verletIntegration( in Vec3 pos, in Vec3 prev, in Vec3 force, in Vec3 mass, in Float32 step ){
    Vec3 delta = force / mass * (step*step);
    return pos + ( pos - prev ) + delta;
}


function SimSpringStrand.UpdatePose?( io IPose pose ){
}



function Index SimSpringStrand.GetRootNodeIndex(){
    return this.nodeIndices[0][0];
}


function SimSpringStrand.SetSubBase!( in String nodeName ){
}

function Index SimSpringStrand.GetSubBaseIndex(){
    return this.subBaseIndex;
}

function Xfo SimSpringStrand.GetSubBaseXfo(){
    return this.xfos[0][ this.subBaseIndexInternal ];
}

function SimSpringStrand.OffsetByCentroid!( io IPose pose, Xfo xfo ){
}

function SimSpringStrand.ResetToReferencePose!() {
}

function String SimSpringStrand.GetName() {
    return this.name;
}

function Boolean SimSpringStrand.IsReady(){
    return this.ready;
}

function SimSpringStrand.Finalize!(){
    this.ready = true;
}


function SimSpringStrand.DrawSolver!() {
}

/**
    Implementation of the FABRIK IK Algorithm
    Please see http://andreasaristidou.com/publications/FABRIK.pdf for more details

Inverse Kinematics is defined as the problem of determining a set of appropriate joint
configurations for which the end effectors move to desired positions as smoothly, rapidly, and
as accurately as possible. However, many of the currently available methods suffer from high
computational cost and production of unrealistic poses. In this work, a novel heuristic method,
called Forward And Backward Reaching Inverse Kinematics (FABRIK), is described and compared with
some of the most popular existing methods regarding reliability, computational cost and
conversion criteria. FABRIK avoids the use of rotational angles or matrices, and instead finds
each joint position via locating a point on a line. Thus, it converges in fewer iterations,
has low computational cost and produces visually realistic poses.
Constraints can easily be incorporated within FABRIK and multiple links with
multiple end effectors are also easily supported.

http://www.andreasaristidou.com/FABRIK.html
Dr Andreas Aristidou

Arguments
----------
=============== ============ =====================================
Name            Type         Description
=============== ============ =====================================
basePose        Xfo[]        The initial pose of the chain. Often defined by a reference pose, or an fk pose generated by an animation system. 
goalPosition    Vec3         The goal position that the chain will be solved towards.
result          Xfo[]        The computed ik pose of the chain of bones.
=============== ============ =====================================


*/

require Math;
require Characters;
require FABRIK;



object FABRIKSolver : IFABRIKSolver {
    String        name;
    Boolean       ready;
    Skeleton      skeleton;        // sleketon
    DrawingHandle handle;

    Bone          bones[];         // the bones
    Xfo           xfos[];          // the xfo of bone
    Index         nodeIndices[];   // the bone index on the skeleton
    Index         subBaseIndex;    // the index sub-base bone on skeleton
    Index         subBaseIndexInternal;  // internally use

    Integer       num_bones;       // number of bone count
    Scalar        chain_length;    // length for root to end(tip) at full extension
    Scalar        precision;       // precision
    Integer       max_iteration;   // max iteration

};


function FABRIKSolver( Ref<Skeleton> skeleton, io DrawingHandle handle, in String boneNames[] ){

    this.ready = false;
    this.skeleton = skeleton;
    this.handle = handle;
    this.precision = 0.0001f;
    this.max_iteration = 15;

    this.num_bones = boneNames.size();
    this.bones.resize( this.num_bones );
    this.xfos.resize( this.num_bones );
    this.nodeIndices.resize( this.num_bones );
    this.name = this.type() +":" + this.skeleton.name +":" + boneNames[boneNames.size-1];

    ////////////////////////////////////////////////////////////////////////////////////
    Xfo xfos[];
    Index indices[];
    for ( Index i=0; i < this.num_bones; i++) {
        Index boneindex = skeleton.findBone( boneNames[i] );
        this.nodeIndices[ i ] = boneindex;
        Bone bone = skeleton.getBone( boneindex );
        this.xfos[i] = bone.referencePose;
        bone.parentIndex = i-1;
        bone.length = 0.0f;  // must culculate later
        //bone.radius = 1.0f;
        bone.name = "FABRIKSolver:bones-" + skeleton.getBone( boneindex ).name;
        report( "add bone["+i+"]: " + bone.name );

        this.bones[i] = bone;
    }

    // calculate bone length and total chain length
    this.chain_length = 0.0f;
    for (Index i=0; i < this.num_bones - 1; i++) {

        Xfo tmp_parent = this.bones[i].referencePose;

        Scalar length = abs( ( this.xfos[i+1].tr - this.xfos[i].tr).length() );
        if ( isZero( length )) {
            setError( "zero length bone found" );
        }

        report( "bone length ["+i+"]: " + length);
        this.bones[i].length = length;
        this.chain_length += length;

        //report( "length["+i+"]: "+length);
    }
    report( "total chain_length is :" + this.chain_length );

}

////////////////////////////////////////////////////////////////////////////////////////
/// implement interface IFABRIKSolver
function FABRIKSolver.Solve!( io IPose pose, in Vec3 effector_position ){
    this.EvaluateBoneTransforms( pose, effector_position );
}


function FABRIKSolver.UpdatePose?( io IPose pose ){
    for ( Index i=this.subBaseIndexInternal; i < this.nodeIndices.size; i++ ){
        pose.setBoneXfo( this.nodeIndices[i], this.xfos[i] );
    }
}



function FABRIKSolver.SetSubBase!( in String nodeName ){
    this.subBaseIndex = this.skeleton.findBone( nodeName );

    // search index in this.xfos
    Boolean hit = false;
    for( Index i=0; i < this.nodeIndices.size; i++ ){
        if( this.subBaseIndex == this.nodeIndices[i] ){
            this.subBaseIndexInternal = i;
            hit = true;
            break;
        }
    }

    if( !hit ){
        setError( "no sub-base node found: " + nodeName );
    }
}

function Index FABRIKSolver.GetSubBaseIndex(){
    return this.subBaseIndex;
}

function Xfo FABRIKSolver.GetSubBaseXfo(){
    return this.xfos[ this.subBaseIndexInternal ];
}

function FABRIKSolver.OffsetByCentroid!( io IPose pose, Xfo xfo ){
    this.xfos[this.subBaseIndexInternal].tr = pose.getBoneXfo( this.subBaseIndex ).tr;
    for ( Index i=this.subBaseIndexInternal + 1; i < this.nodeIndices.size; i++ ){
        this.BackwardReach( i, i-1 );
        pose.setBoneXfo( this.nodeIndices[i], this.xfos[i] );
    }
    //this.UpdatePose( pose );
}

////////////////////////////////////////////////////////////////////////////////////////

function FABRIKSolver.EvaluateBoneTransforms!( io IPose pose, in Vec3 effector_position ){

    Xfo rootXfo = pose.getBoneXfo( this.nodeIndices[0] );
    Boolean is_bone_location_updated = false;
    Scalar root_to_target_distance = abs(
        ( rootXfo.tr - effector_position ).length
    );

    if ( root_to_target_distance * 0.95> this.chain_length ) {
        // full extension
        for (Integer link_id = 1; link_id < this.num_bones; link_id++) {
            Bone parent = this.bones[ link_id - 1 ];
            Xfo  parentXfo = this.xfos[ link_id - 1 ];
            Vec3 diff = effector_position - parentXfo.tr;
            this.xfos[ link_id ].tr = parentXfo.tr + diff.normalize() * parent.length;

        }
        is_bone_location_updated = true;

    } else {
        this.ResetToReferencePose();
        this.SolvePosition( effector_position );
        is_bone_location_updated = true;
    }

    if (is_bone_location_updated) {

        Boolean is_rot_changed = this.SolveRotation( pose, effector_position );
        for (Index i = 0; i < this.num_bones; i++) {
            Xfo tmp = pose.getBoneXfo( this.nodeIndices[i] );
            tmp.tr = this.xfos[i].tr;

            if (is_rot_changed) {
                tmp.ori = this.xfos[i].ori;
            }
            //pose.setBoneXfo( this.nodeIndices[i], tmp );
        }

    }
}

function FABRIKSolver.reportBoneLength( in String mes ){
    Scalar total = 0.0;
    for (Index i=0; i < this.num_bones - 1; i++) {
        Scalar length = abs( ( this.xfos[i+1].tr - this.xfos[i].tr).length() );
        report( mes +" bone length ["+i+"]: " + length);
        total += length;
    }
    report( mes+" bone length total: " + total);
}


function FABRIKSolver.ResetToReferencePose!() {
    for ( Index i=0; i < this.num_bones; i++ ){
        this.xfos[i] = this.bones[i].referencePose;
    }
}

/// if effector is within reach, calculate bone translations to position tip
/// at  effector location.
// l118
function FABRIKSolver.SolvePosition!( in Vec3 effector_position ) {

    Index tip_bone_index = this.num_bones - 1;
    Bone tip = this.bones[tip_bone_index];
    Xfo tipXfo = this.xfos[tip_bone_index];
    Scalar slop = abs( (tipXfo.tr - effector_position).length ) - tip.length;
    if (slop < this.precision ) {
        return;
    }

    Integer iteration_count = 0;
    while ( (slop > this.precision) && (iteration_count < this.max_iteration) ){
        // "Forward Reaching" stage - adjust bones from End effector to Root
        this.ForwardReachOnTail( effector_position );
        for (Index link_id = tip_bone_index - 1; link_id > 0; link_id--) {
            this.ForwardReach( link_id, link_id+1 );
        }

        // "Backward Reaching" stage - adjust bones from root.
        for (Index link_id = 1; link_id < this.num_bones; link_id++ ){
            this.BackwardReach( link_id, link_id-1 );
        }
        this.BackwardReachOnTail( effector_position );

        slop = abs(
            this.bones[ tip_bone_index ].length
            - distance( this.xfos[tip_bone_index].tr, effector_position)
        );
        iteration_count++;
    }

}


/// re-orientation of bone local axes after translation calculation
function Boolean FABRIKSolver.SolveRotation!( io IPose pose, in Vec3 effector_position ) {
    Boolean is_changed = false;
    for (Index link_id = 0; link_id < this.num_bones; link_id++ ){
        Vec3 tail_pos;
        if ( link_id == this.num_bones - 1){
            tail_pos = effector_position;
        } else {
            tail_pos = pose.getBoneXfo( this.nodeIndices[ link_id+1 ]).tr;
        }

        Vec3 old_dir = tail_pos - pose.getBoneXfo( this.nodeIndices[ link_id ]).tr;
        if ( link_id == this.num_bones - 1){
            tail_pos = effector_position;
        } else {
            tail_pos = this.xfos[ link_id +1 ].tr;
        }

        Vec3 new_dir = tail_pos - this.xfos[ link_id ].tr;
        if ( !IsValidToEvaluate( old_dir ) || !IsValidToEvaluate( new_dir ) ){
            // effector on bone, same position
            this.xfos[link_id].ori = this.xfos[link_id].ori;
            continue;
        } else {
            is_changed = true;
        }
        old_dir.setUnit();
        new_dir.setUnit();

        // x axis point its tip
        Quat rot = Quat( Euler( 0, -HALF_PI, 0 , RotationOrder( 'xyz' )) );
        this.xfos[link_id].ori.setFromDirectionAndUpvector( new_dir, Vec3(0, 0, 100000) );
        //this.xfos[link_id].ori *= rot;
    }

    return is_changed;
}




function FABRIKSolver.ForwardReach!( in Integer target_index, in Integer child_index ){
    if ( target_index > this.num_bones -1 || child_index > this.num_bones -1 ){
        setError( "index > bone count ---- target:" + target_index + "  limit: " + child_index + "bone count: " + this.num_bones);
    }

    this.xfos[ target_index ].tr = SolveJoint(
            this.xfos[ target_index ],
            this.xfos[ child_index ],
            this.bones[ target_index ].length
    );
}


/// adjust bones from root
function FABRIKSolver.BackwardReach!( in Integer target_index, in Integer parent_index ){
    if ( target_index > this.num_bones -1 || parent_index > this.num_bones -1 ){
        setError( "index > bone count ---- target:" + target_index + "  limit: " + parent_index + "bone count: " + this.num_bones);
    }
    this.xfos[ target_index ].tr = SolveJoint(
            this.xfos[ target_index ],
            this.xfos[ parent_index ],
            this.bones[ target_index -1 ].length
    );
}

function FABRIKSolver.ForwardReachOnTail!( in Vec3 effector_position ){
    this.xfos[ this.num_bones -1 ].tr = SolveJoint(
            this.xfos[ this.num_bones -1 ].tr,
            effector_position,
            this.bones[ this.num_bones -1 ].length
    );
}

function FABRIKSolver.BackwardReachOnTail!( in Vec3 effector_position ){
    this.xfos[ this.num_bones - 1 ].tr = SolveJoint(
            this.xfos[ this.num_bones - 1 ].tr,
            this.xfos[ this.num_bones - 1 -1 ].tr,
            this.bones[ this.num_bones - 1 -1 ].length
    );
}

function String FABRIKSolver.GetName() {
    return this.name;
}

function Boolean FABRIKSolver.IsReady(){
    return this.ready;
}

function FABRIKSolver.Finalize!(){
    this.ready = true;
}

/*
function FABRIKSolver.DrawXfo(){
    InlineDrawing drawing = OGLInlineDrawing_GetInstance();
    InlineTransform tra = StaticInlineTransform('characterTransform', Xfo());
    drawing.getRoot().addChild( tra );

    Xfo all[];
    all.resize( this.bones.size() );

    for (Index i = 0; i < all.size(); i++ ){
        all[i] = this.xfos[i];
    }

    drawXfoArray( tra, "hoge", all, Color( 0, 255, 0 ), 0.5f );

}
*/

inline Boolean IsValidToEvaluate( in Vec3 v ){
    if ( v.length == 0.0 || v.length.isNaN ){
        return false;
    }
    return true;
}

inline Vec3 SolveJoint( in Xfo a, in Xfo b, Scalar length ){
    return SolveJoint( a.tr, b.tr, length );
}

inline Vec3 SolveJoint( in Mat44 a, in Mat44 b, Scalar length ){
    return SolveJoint( a.translation(), b.translation(), length );
}

inline Vec3 SolveJoint( in Vec3 a, in Vec3 b, Scalar length ){
    Vec3 diff = a - b;
    if ( diff.length == 0 ) {
        return b;
    } else {
        return b + diff.normalize() * length;
    }
}

inline Scalar distance( in Vec3 a, in Vec3 b ){
    Vec3 diff;
    diff = a - b;
    return abs( diff.length );
}

require InlineDrawing;

function FABRIKSolver.DrawSolver!() {
    this.drawBones( this.xfos, this.bones, this.handle );
}
function FABRIKSolver.drawBones!( Xfo xfos[], Bone links[], io DrawingHandle handle) {
    InlineDrawing draw = handle.getDrawing();
    InlineShader shader = draw.registerShader(OGLSurfaceShader('surface'));
    InlineMaterial phong = shader.getOrCreateMaterial("phong");

    for(Integer i=0; i<links.size; i++){
        InlineTransform boneTransform = handle.getRootTransform().getChild(
                                    this.GetName() +":" +i +":"+ links[i].name);
        if(boneTransform == null){
            Bone bone = links[i];
            boneTransform = StaticInlineTransform(
                            this.GetName() +":" +i +":"+bone.name, xfos[i] );
            handle.getRootTransform().addChild(boneTransform);

            InlineShape boneShape = constructBoneShape(i, links);
            GeometryAttributes attributes = boneShape.getAttributes();
            Vec3Attribute  normals = attributes.getAttribute('normals', Vec3Attribute);
            InlineInstance boneInstance = SimpleInlineInstance( bone.name + 'Instance', boneTransform, boneShape, phong);
            boneInstance.setInstanceUniform(InlineUniform('u_diffuseColor', bone.color));
        }
        else{
            boneTransform.setLocalXfo(0, xfos[i]);
        }
    }
}


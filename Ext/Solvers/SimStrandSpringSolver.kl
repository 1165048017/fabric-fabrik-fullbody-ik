/**
    Implementation of the FABRIK IK Algorithm
    Please see http://andreasaristidou.com/publications/FABRIK.pdf for more details

Inverse Kinematics is defined as the problem of determining a set of appropriate joint
configurations for which the end effectors move to desired positions as smoothly, rapidly, and
as accurately as possible. However, many of the currently available methods suffer from high
computational cost and production of unrealistic poses. In this work, a novel heuristic method,
called Forward And Backward Reaching Inverse Kinematics (FABRIK), is described and compared with
some of the most popular existing methods regarding reliability, computational cost and
conversion criteria. FABRIK avoids the use of rotational angles or matrices, and instead finds
each joint position via locating a point on a line. Thus, it converges in fewer iterations,
has low computational cost and produces visually realistic poses.
Constraints can easily be incorporated within FABRIK and multiple links with
multiple end effectors are also easily supported.

http://www.andreasaristidou.com/FABRIK.html
Dr Andreas Aristidou

*/

require Math;
require Characters;
require FABRIK;



object SimSpringStrand: IFABRIKSolver {
    String        name;
    Boolean       ready;
    Skeleton      skeleton;        // sleketon
    DrawingHandle handle;
    Index         subBaseIndex;    // the index sub-base bone on skeleton
    Index         subBaseIndexInternal;  // internally use

    Index         numberOfStrands;
    Index         rootNodeIndices[];

    Bone          bones[][];         // the bones
    Xfo           xfos[][];          // the xfo of bone
    Index         nodeIndices[][];   // the bone index on the skeleton
    Scalar        chainLengths[];
    Integer       max_iteration;   // max iteration

    Mat44         rootControllers[];

    //////////////////////////////////////
    Vec3          positionPrev[][];

    Scalar        frameCount;
    Scalar        framePrev;
    Scalar        deltaTime;

};


function SimSpringStrand( Ref<Skeleton> skeleton, io DrawingHandle handle, in String boneNames[][] ){

    this.ready = false;
    this.skeleton = skeleton;
    this.handle = handle;
    //this.precision = 0.005f;
    this.max_iteration = 150;

    //this.num_bones = boneNames.size();
    this.numberOfStrands = boneNames.size;
    this.bones.resize( boneNames.size );
    this.xfos.resize( boneNames.size );
    this.chainLengths.resize( boneNames.size );
    this.nodeIndices.resize( boneNames.size );
    this.rootNodeIndices.resize( boneNames.size );
    this.positionPrev.resize( boneNames.size );
    this.name = this.type() +":" + this.skeleton.name +":" + boneNames[boneNames.size-1];

    for (Index j=0; j < boneNames.size; j++ ){
        this.rootNodeIndices[j] = skeleton.findBone( boneNames[j][0] );

        for ( Index i=0; i < boneNames[j].size; i++) {
            Index boneindex = skeleton.findBone( boneNames[j][i] );
            this.nodeIndices[ j ].push( boneindex );
            Bone bone = skeleton.getBone( boneindex );
            this.xfos[j].push( bone.referencePose );
            bone.length = 0.0f;  // must culculate later
            bone.name = "FABRIKSolver:bones-" + skeleton.getBone( boneindex ).name;
            //report( "add bone["+j+"]["+i+"]: " + bone.name + "   " + bone.length );
            this.positionPrev[j].push( bone.referencePose.tr );
            if ( i != 0 ){
                bone.parentIndex = this.nodeIndices[j][ i-1 ];
            } else {
                bone.parentIndex = 0;
            }

            this.bones[j].push( bone );
        }
    }

    for (Index j=0; j < boneNames.size; j++ ){
        // calculate bone length and total chain length
        this.chainLengths[j] = 0.0f;
        for (Index i=0; i < this.bones[j].size - 1; i++) {

            Xfo tmp_parent = this.bones[j][i].referencePose;

            Scalar length = abs( ( this.xfos[j][i+1].tr - this.xfos[j][i].tr).length() );
            if ( isZero( length )) {
                setError( "zero length bone found" );
            }

            //report( "bone length ["+i+"]: " + length);
            this.bones[j][i].length = length;
            this.chainLengths[j] += length;
        }
    }


}

////////////////////////////////////////////////////////////////////////////////////////
/// implement interface ISimSpringStrand
function SimSpringStrand.Solve!( io IPose pose, io Mat44 rootControllers[] ){

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        pose.setBoneXfo( this.rootNodeIndices[ i ], Xfo( rootControllers[i] ));
    }

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        this.solveEachStrand( pose, rootControllers[i].translation(), i );
    } 

    for ( Index i=0; i < this.numberOfStrands; i++ ) {
        for ( Index j=0; j < this.positionPrev[i].size; j++){
            pose.setBoneXfo( this.nodeIndices[i][j], this.positionPrev[i][j] );
        }
    }
}

function SimSpringStrand.Solve!( io IPose pose, in Vec3 effectorPosition ){

}

function SimSpringStrand.solveEachStrand!( io IPose pose, in Vec3 effector_position, in Index index ){
    //VerletStrandBinding verletStrand = verletStrands[index];
    for (Index j = 0; j < this.nodeIndices[ index ].size; j++) {
        this.solveEachEadge( pose, effector_position, this.bones[index], index, j);
    }
}

function SimSpringStrand.UpdateFrame!( in Scalar fc ){
    this.framePrev  = this.frameCount;
    this.frameCount = fc;
    this.deltaTime  = (this.frameCount - this.framePrev) / 30.0;
    //this.deltaTime  = 1/30;
}

/// for shortcut
inline function Xfo getReferenceLocalPose( io Skeleton skeleton, Index index ){
    return skeleton.getReferenceLocalPose( index );
}


////////////////////////////////////////////////////////////////////////////////////////
///
///
///
function SimSpringStrand.solveEachEadge!(
                                            io IPose pose,
                                            in Vec3 effector_position,
                                            io Bone bones[],
                                            in Index strandIndex,
                                            in Index _nodeIndex
                                        ){
    ////////////////////////////////////////////////////////////////////////////////////
    Vec3 gravity = Vec3( 0.0, -0.98, 0.0 );
    Scalar dampening = 0.001;
    Scalar springStrengths = 1.0;

    ////////////////////////////////////////////////////////////////////////////////////
    Index nodeIndex = this.nodeIndices[ strandIndex ][ _nodeIndex ];
    Bone  thisBone  = this.bones[ strandIndex ][ _nodeIndex ];
    Xfo xfoCurr = this.xfos[ strandIndex ][ _nodeIndex ];

    ////////////////////////////////////////////////////////////////////////////////////
    Xfo parentAttachedXfo = pose.getBoneXfo(
                    this.skeleton.getBone( nodeIndex ).parentIndex );
    Xfo parentSimulatedXfo = parentAttachedXfo;
    Xfo attachedXfo = parentAttachedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );
    parentAttachedXfo = attachedXfo;

    Vec3 positionPrevTemp[] = this.positionPrev[strandIndex];


    Xfo testXfo = parentSimulatedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );
    Vec3 attachedTr = testXfo.tr + testXfo.ori.rotateVector( Vec3( thisBone.length, 0.0, 0.0) );

    Scalar mass = 1.0;
    Vec3 force = gravity;
    Vec3 trCurr = xfoCurr.tr + xfoCurr.ori.rotateVector( Vec3( thisBone.length, 0.0, 0.0) );
    Vec3 temp = trCurr;
    this.positionPrev[ strandIndex ][ _nodeIndex ] = this.positionPrev[ strandIndex ][ _nodeIndex ].linearInterpolate(trCurr, dampening);

    force += ((attachedTr - trCurr) * springStrengths);

    trCurr += (trCurr - this.positionPrev[strandIndex][_nodeIndex]) + ((force / mass) * (this.deltaTime * this.deltaTime));


    // Now apply the inter-link constraints that keep the chain together
    Vec3 prevAnchor, nextAnchor;
    if( _nodeIndex==0 ){
        prevAnchor = attachedXfo.tr;
    }
    else{
        prevAnchor = this.positionPrev[strandIndex][_nodeIndex-1];
    }
    Vec3 prevVec = (prevAnchor - trCurr);
    Scalar prevVecLength = prevVec.length();
    Scalar boneLength = thisBone.length;
    trCurr += (prevVec * ((prevVecLength - boneLength)/prevVecLength)) * 0.5;

    // is not end node
    if( _nodeIndex < this.nodeIndices[ strandIndex ].size-1 ){

        nextAnchor = this.positionPrev[ strandIndex ][ _nodeIndex+1];
        Vec3 nextVec = (nextAnchor - trCurr);
        Scalar nextVecLength = nextVec.length();
        Scalar nextBoneLength = this.bones[ strandIndex ][ _nodeIndex+1 ].length;
        trCurr += ( nextVec * ((nextVecLength - nextBoneLength) / nextVecLength) ) * 0.5;
    }

    Vec3 simulatedTr = attachedTr.linearInterpolate(trCurr, 1.0);

    Xfo simulatedXfo = parentSimulatedXfo * getReferenceLocalPose( this.skeleton, nodeIndex );

    Quat boneOffsetRotation;
    boneOffsetRotation.setFrom2Vectors(simulatedXfo.ori.getXaxis(), (simulatedTr - simulatedXfo.tr).unit());
    simulatedXfo.ori = boneOffsetRotation * simulatedXfo.ori;

    this.xfos[ strandIndex ][ _nodeIndex ] = simulatedXfo;

    parentSimulatedXfo = simulatedXfo;
    positionPrevTemp[ _nodeIndex ] = temp;
    this.positionPrev[ strandIndex ][ _nodeIndex ] = temp;
}


function SimSpringStrand.UpdatePose?( io IPose pose ){
}



function SimSpringStrand.SetSubBase!( in String nodeName ){
}

function Index SimSpringStrand.GetSubBaseIndex(){
    return this.subBaseIndex;
}

function Xfo SimSpringStrand.GetSubBaseXfo(){
    return this.xfos[0][ this.subBaseIndexInternal ];
}

function SimSpringStrand.OffsetByCentroid!( io IPose pose, Xfo xfo ){
}

function SimSpringStrand.ResetToReferencePose!() {
}

function String SimSpringStrand.GetName() {
    return this.name;
}

function Boolean SimSpringStrand.IsReady(){
    return this.ready;
}

function SimSpringStrand.Finalize!(){
    this.ready = true;
}


function SimSpringStrand.DrawSolver!() {
}

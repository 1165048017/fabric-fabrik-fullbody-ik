/*

*/
require Math;
require Characters;


function Bone Skeleton.getBone( in String name ){
    Index i = this.findBone( name );
    return this.getBone( i );
}

function Skeleton.addBone!( in String name, in String parentName, Xfo xfo ){
    Scalar length = 0.0;
    this.addBone( name, parentName, xfo, length );
}
function Skeleton.addBone!( in String name, in String parentName, Xfo xfo, in Scalar length ){
    Bone bone = this.boneGenerator( name, parentName, xfo, length );
    this.addBone( bone );
}

function Bone Skeleton.boneGenerator( in String name, in String parentName, Xfo xfo, Scalar length ){
    Bone bone;

    bone.name = name;
    bone.parentIndex = -1;
    Index parentIndex = this.findBone( parentName );

    Xfo parentXfo();
    if ( parentIndex < 0 ){
        bone.parentIndex = -1;
        parentXfo = this.bones[ parentIndex ].referencePose;
    } else {
        bone.parentIndex = parentIndex;
    }

    // compute the angles
    //Scalar random = 0.5 - mathRandomScalar(12, i);
    //Scalar xAngle = sin(random * 0.4 + Scalar(i) * 0.03) * 0.5;
    //Scalar zAngle = cos(0.11 + Scalar(i) * 0.01) * 0.1;

    //Xfo xfo;
    //xfo.tr = Vec3(boneLength, 0.0, 0.0);
    //xfo.ori.setFromEulerAngles(Vec3(xAngle, 0.0f, zAngle));
    //bone.referencePose = parentXfo * xfo;
    bone.referencePose = xfo;
    bone.length = length;
    bone.radius = 0.1;
    bone.setFlag(BONEFLAG_DEFORMER);

    return bone;
}


/*---------------------------------------------------------------------------------------
//
// bone 間の接続を表現する隣接リスト使ったグラフ...
// 普通に skeleton 継承した方がいいかもしれない
//
---------------------------------------------------------------------------------------*/
object FFBIKEdge {
    Index a;
    Index b;

    Vec3 referencePose;  // diff vector a to b
};

function FFBIKEdge( in Index _a, in Index _b ){
    this.a = _a;
    this.b = _b;
}

function String FFBIKEdge.getName(){
    return "FFBIKEdge:" + this.a + "to" + this.b;
}

object FFBIKGraph {
    Skeleton skeleton;
    Index nodes[Index][];
    Index controlledNodes[];
    FFBIKEdge edges[];

    // for debug draw
    Points points;
    Lines lines;
};

// constructor
function FFBIKGraph( Ref <Skeleton> skeleton ){
    //this.lines = Lines();
    this.skeleton = skeleton;
    this.points = Points();
    this.lines = Lines();
    this.controlledNodes.resize(0);
}


function FFBIKGraph.finalize!(){
    this.distinctNodes();
    this.points.resize( this.getNodeCount() );
    this.lines.clear();
}

function FFBIKGraph.addEdge!( in String a, in String b ){
    Index ba = this.skeleton.findBone( a );
    Index bb = this.skeleton.findBone( b );
    FFBIKEdge edge = FFBIKEdge( ba, bb );
    this.nodes[ ba ].push( bb );
    this.nodes[ bb ].push( ba );
    this.edges.push( edge );
}

function FFBIKGraph.addNode( String boneName ){
    Index id = this.skeleton.findBone( boneName );
    this.nodes[ id ];
}

function FFBIKGraph.addNode!( String boneName, Boolean isControlled ){
    Index id = this.skeleton.findBone( boneName );
    this.nodes[ id ];
    this.markAsControlled( id );
}

function FFBIKGraph.registerControllBone!( String boneName ){
    Index id = this.skeleton.findBone( boneName );
    this.controlledNodes.push(id);
}

function FFBIKGraph.markAsControlled!( in Index id ){
    this.controlledNodes.push(id);
}

function Boolean FFBIKGraph.isControlledNode( in Index id ){
    return isExistsIn( id, this.controlledNodes );
}

function Index[] FFBIKGraph.searchNoisy( io Index id, io Index array[] ){
    Index results[];
    Index counter[] = this.nodes[ id ];
    for (Index i=0; i < counter.size; i++ ){
        Boolean hit = false;
        for (Index j=0; j < array.size; j++ ){
            if (counter[i] == array[j] ){
                hit = true;
            }
        }

        if ( !hit ){
            results.push( counter[i] );
        }
    }

    //distinct( results );
    return results;
}
/*
function FFBIKGraph.addNode( Bone bone ){
    this.nodes[ bone ];
}
*/

function FFBIKGraph.search( Bone start, Bone end ){
    //result;
    //return [];
}

function FFBIKGraph.distinctNodes!(){
    for( k,v in this.nodes){
        distinct( this.nodes[k] );
    }
}
function String FFBIKGraph.getName(){
    return "hello";
}

function String FFBIKGraph.getInlineEdgeName(){
    return this.getName() + ":InlineEdges";
}
function String FFBIKGraph.getInlineNodeName(){
    return this.getName() + ":InlineNodes";
}

function Size FFBIKGraph.getEdgeCount(){
    return this.edges.size;
}

function Size FFBIKGraph.getNodeCount(){
    Size s=0;
    for (k, v in this.nodes){
        s++;
    }
    return s;
}


function FFBIKEdge FFBIKGraph.getEdge( in Index index_a, in Index index_b){
    for ( Index i=0; i< this.getEdgeCount(); i++ ){

        // a,  b
        if ( ( this.edges[i].a == index_a )
            && ( this.edges[i].b == index_b )) {
            return this.edges[i];
        }

        // b,  a
        if ( ( this.edges[i].a == index_b )
            && ( this.edges[i].b == index_a )) {
            return this.edges[i];
        }
    }
    setError("edge not found");
    return null;
}

function FFBIKEdge FFBIKGraph.getEdge( in String aName, in String bName ){
    for ( Index i=0; i< this.getEdgeCount(); i++ ){

        // a,  b
        if ( (this.skeleton.getBone( this.edges[i].a ).name == aName)
            && (this.skeleton.getBone( this.edges[i].b ).name == bName)) {
            return this.edges[i];
        }

        // b,  a
        if ( (this.skeleton.getBone( this.edges[i].a ).name == bName)
            && (this.skeleton.getBone( this.edges[i].b ).name == aName)) {
            return this.edges[i];
        }
    }
    setError("edge not found");
    return null;
}

// Generates a set of inline shapes nested under the provided rootTransform. 
function FFBIKGraph.drawEdges!(in ISkeleton skeleton, io IPose pose, io DrawingHandle handle ) {
    GeometryAttributes attributes = this.lines.getAttributes();
    Vec3Attribute positions       = attributes.getOrCreateAttribute('positions', Vec3Attribute);
    Vec3Attribute normals         = attributes.getOrCreateAttribute('normals', Vec3Attribute);
    Vec3Attribute velocities      = attributes.getOrCreateAttribute('velocities', Vec3Attribute);
    ColorAttribute vertexColors   = attributes.getOrCreateAttribute('vertexColors', ColorAttribute);
    ScalarAttribute ratios        = attributes.getOrCreateAttribute('ratios', ScalarAttribute);
  
    InlineDrawing draw = handle.getDrawing();
    InlineShader shader = draw.registerShader(OGLLinesShader());
    InlineMaterial mat  = shader.getOrCreateMaterial('mat');
    InlineTransform edgeTransform = handle.getRootTransform().getChild( this.getInlineEdgeName() );

    if(edgeTransform == null){
        mat.setUniform('u_normalIsTangent',  0);
        mat.setUniform('u_shadingAmount', 0.5);
        mat.setUniform('u_vertexColorAmount', 0.5);
        mat.setUniform('u_rootColor', Color( 0, 255, 255));
        mat.setUniform('u_tipColor', Color( 0, 0, 0));

        edgeTransform = StaticInlineTransform( this.getInlineEdgeName(), Xfo() );
        handle.getRootTransform().addChild(edgeTransform);

        for(Integer i=0; i<this.getEdgeCount(); i++){

            this.lines.addLine(
                pose.getBoneXfo( this.edges[i].a ).tr,
                pose.getBoneXfo( this.edges[i].b ).tr
            );
        }

        InlineShape shape = draw.registerShape( InlineLinesShape('lines', this.lines) );
        InlineInstance instance = mat.addInstance(SimpleInlineInstance(this.getInlineEdgeName(), edgeTransform, shape));
    } else {
        for(Integer i=0; i< this.getEdgeCount(); i++){
            this.lines.setPosition( i*2,   pose.getBoneXfo( this.edges[i].a ).tr );
            this.lines.setPosition( i*2+1, pose.getBoneXfo( this.edges[i].b ).tr );
        }
    }

    this.lines.incrementVersion();
    positions.incrementVersion();

}


// Generates a set of inline shapes nested under the provided rootTransform. 
function FFBIKGraph.drawNodes!(in ISkeleton skeleton, io IPose pose, io DrawingHandle handle ){
    //Points points();
    GeometryAttributes attributes = this.points.getOrCreateSizesAttribute();
 
    InlineDrawing draw = handle.getDrawing();
    InlineShader shader = draw.registerShader(OGLFlatShader());
    InlineShader surfaceShader = draw.registerShader(OGLSurfaceShader());
    InlineMaterial mat  = shader.getOrCreateMaterial('mat');
    InlineMaterial pointsMaterial = shader.getOrCreateMaterial("points");
    pointsMaterial.setUniform('u_color', Color(1.0, 0.0, 0.0));

    InlineTransform transform = handle.getRootTransform().getChild(
                                                    this.getInlineNodeName() );

    if( transform == null){

        // initialize points
        this.points.clear();
        this.points.resize( this.getNodeCount() );
        transform = StaticInlineTransform( this.getInlineNodeName(), Xfo() );
        handle.getRootTransform().addChild( transform );
        InlineShape shape = draw.registerShape( InlinePointsShape( this.getInlineNodeName(), this.points));
        InlineInstance instance = mat.addInstance(InlineInstance( this.getInlineNodeName(), transform, shape, pointsMaterial));

        Index i=0;
        for( k,v in this.nodes ){
            this.points.addPoint( pose.getBoneXfo( k ).tr );
            i++;
        }
    } else {
        // update points
        Index i=0;
        for( k,v in this.nodes ){
            if ( i >= this.points.size ){
                setError( "hogeeeeeeeeeeeeeeeee" );
            } else {
                this.points.setPosition( i, pose.getBoneXfo( k ).tr );
            }
            i++;
        }
    }
    this.points.incrementPositionsVersion();

}


/*---------------------------------------------------------------------------------------
//
//         custom pose
//
---------------------------------------------------------------------------------------*/
object FFBIKPose : Pose {
};

function FFBIKPose( Skeleton skeleton ){
    this.skeleton = skeleton;
    this.version = mathRandomInteger(55540, UInt32(this.skeleton.getVersion()));
    this.reset();

}

function FFBIKPose.updateXfo!( Index id, Xfo xfo ){
    this.xfos[ id ] = xfo;
    this.valid[ id ] = true;
}

function FFBIKPose.test!(){
    //for (Index i=0; i< this.skeleton.bones.size; i++ ){
    //    this.updateXfo( i, Xfo( Vec3( 5, 0, 0) ));
    //}
    this.updateXfo( 0, Xfo( Vec3( 5, 0, 0) ));
}


/*---------------------------------------------------------------------------------------
//
//         utility
//
---------------------------------------------------------------------------------------*/
// FIXME: O(n^2) need more efficient algorithm 
function distinct(io Bone array[]) {
    distinct( array, array.size );
}
function distinct(io Bone array[], Size length) {
    Index i, j;
    Index newLength = 1;  // new length of modified array

    for( i=1; i< length; i++ ){

        for( j=0; j< newLength ; j++){
            if(array[i] == array[j])
                break;
        }

        /* if none of the values in index[0..j] of array is not same as array[i],
           then copy the current value to corresponding new position in array */
        if( j == newLength ){
            array[newLength++] = array[i];
        }
    }
    array.resize( newLength );
}

function UInt32 Bone.hash(){
    return this.name.hash() ^ this.parentIndex.hash();
}


function Boolean ==(Bone lhs, Bone rhs) {
    if ( lhs.name        != rhs.name )      { return false; }
    if ( lhs.parentIndex != rhs.parentIndex){ return false; }
    //if ( lhs.length      != rhs.length )    { return false; }
    //if ( lhs.radius      != rhs.radius)     { return false; }
    return true;
}
/*---------------------------------------------------------------------------------------
*/
function distinct(io Index array[]) {
    distinct( array, array.size );
}
function distinct(io Index array[], Size length) {
    Index i, j;
    Index newLength = 1;  // new length of modified array

    for( i=1; i< length; i++ ){

        for( j=0; j< newLength ; j++){
            if(array[i] == array[j])
                break;
        }

        /* if none of the values in index[0..j] of array is not same as array[i],
           then copy the current value to corresponding new position in array */
        if( j == newLength ){
            array[newLength++] = array[i];
        }
    }
    array.resize( newLength );
}

/*---------------------------------------------------------------------------------------
*/
inline function Boolean isExistsIn( in Index id, in Index array[] ){
    for (Index i=0; i < array.size; i++ ){
        if (id == array[i] ){
            return true;
        }
    }
    return false;
}

/*---------------------------------------------------------------------------------------
//
//         entry point for checking compilation
//
---------------------------------------------------------------------------------------*/
//operator entry(){ report("load done"); }
